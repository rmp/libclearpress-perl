<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>ClearPress Framework</title>
  <link rel="stylesheet" type="text/css" href="clearpress.css"/>
</head>

 <body>
  <h1>ClearPress Framework</h1>
<div class="main">

<h2>Streaming Views</h2>
<p>
 One of the limitations imposed by the standard ClearPress
 templated-view mechanism is that an entire response needs to be
 processed <i>en-bloc</i> - that is to say, completed on the server
 all-at-once then returned to the client in one go. This naturally
 suits many, if not most, real-world examples which involve a
 relatively quick, or small single page response which can be served
 in this way. However there are other cases which require a bit more
 care. If a page takes longer than around 5 seconds to start returning
 content, the user is likely to become bored of waiting. So if it is
 possible for the application to <i>start</i> doing the work and begin
 to serve the response to the user before it finishes doing the work,
 it should result in a more pleasant user-experience. This act of
 simultaneously processing and serving content is often referred to as
 streaming.
</p>

<p>
 Streamed content of course is not quite as simple as block-based
 templating. Some extra care is required to allow for example,
 database work to occur in between serving chunks of content back to
 the user. Thankfully ClearPress tries to reduce these burdens.
</p>

<p>
 To enable streaming for a view, first define the method
 <code>sub streamed_aspects { }</code>
 in the view class. This overrides the same method in the superclass
 and allows us to return an array of the aspect names we want to
 stream. Lets do that for a listing:

 <code>sub streamed_aspects {
 return [qw(list)];
}
</code>
</p>

<p>
 Ok, now we need to define the method ourselves to actually do the work. As we're likely to be streaming copies of the same template, just with different data, we can still make use of the template toolkit, but we need to handle the chunks ourselves. A simple way to do this is using three files, a header, a footer and the repeated block.
<h3>kid_list_header.tt2</h3>
<code> &lt;table&gt;
  &lt;caption&gt;List of kids&lt;/caption&gt;
  &lt;thead&gt;
   &lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tfoot&gt;
   &lt;tr&gt;&lt;td colspan="2"&gt;some content&lt;/td&gt;&lt;/tr&gt;
  &lt;/tfoot&gt;
  &lt;tbody&gt;
</code>

<h3>kid_list_footer.tt2</h3>
<code>  &lt;/tbody&gt;
 &lt;/table&gt;
</code>

<h3>kid_list_row.tt2</h3>
<code> &lt;tr&gt;&lt;td&gt;[% kid.id %]&lt;/td&gt;&lt;td&gt;[% kid.name %]&lt;/td&gt;&lt;/tr&gt;
</code>
</p>

<p>
 Great! That's the templates taken care of. You should be able to see
 what we're about to do in the view module.

 <h3>lib/Grandkids/view/kid.pm</h3>
 <code>sub list {
  my $self = shift;

  $self->process_template('kid_list_header.tt2');

  my $kids = $self->model->kids();
  for my $kid (@{$kids}) {
    $self->process_template('kid_list_row.tt2', {kid=>$kid});
  }

  $self->process_template('kid_list_footer.tt2');

  return 1;
}
</code>

 Ok, so we are doing our main database query here in one lump. As an
 exercise you could try generating a method like this which uses a
 two-argument SQL LIMIT or cursors to iterate over sets of rows using
 less memory.
</p>

<p>
 Naturally it is also possible to stream responses other than the
 standard text/html. Streaming should work fine with XML or text/plain
 for example.
</p>

</div><!--end main-->

<div id="menu">
 <ul>
  <li><a href="/index.shtml">About</a></li>
  <li><a href="/installing.shtml">Installing</a></li>
  <li><a href="/basics.shtml">The Basics</a></li>
  <li><a href="/rest.shtml">REST</a></li>
  <li><a href="/orm.shtml">ORM / Models</a></li>
  <li><a href="/views.shtml">Views</a></li>
  <li><a href="/routes.shtml">Routes</a></li>
  <li><a href="/streaming.shtml">Streamed content</a></li>
  <li><a href="/mimetypes.shtml">Custom response types</a></li>
  <li><a href="/paging.shtml">Paging Lists</a></li>
  <li><a href="/ajax.shtml">Working with AJAX</a></li>
  <li><a href="/authen.shtml">Authentication</a></li>
  <li><a href="/authz.shtml">Authorisation</a></li>
  <li><a href="/pdf.shtml">Exporting PDFs</a></li>
 </ul>

 <br/><br/><b>Still to come:</b>
 <ul style="font-style:italic">
  <li>Transactions</li>
  <li>Posting XML</li>
  <li>Automated Testing</li>
  <li>Internationalisation</li>
 </ul>
</div>


<div class="footer" style="margin-left:-50px">
<SCRIPT charset="utf-8" type="text/javascript" src="http://ws.amazon.co.uk/widgets/q?ServiceVersion=20070822&MarketPlace=GB&ID=V20070822/GB/gardmalt-21/8001/e9b44bbc-a251-45f1-8386-10affeb751cc"> </SCRIPT> <NOSCRIPT><A HREF="http://ws.amazon.co.uk/widgets/q?ServiceVersion=20070822&MarketPlace=GB&ID=V20070822%2FGB%2Fgardmalt-21%2F8001%2Fe9b44bbc-a251-45f1-8386-10affeb751cc&Operation=NoScript">Amazon.co.uk Widgets</A></NOSCRIPT>
</div>

<div class="footer">
<address><a href="mailto:rmp@psyphi.net">rmp</a></address>
<!-- Created: Mon Jan 19 11:45:21 GMT 2009 -->
<!-- hhmts start -->
Last modified: Tue Jan 26 12:12:00 2010
<!-- hhmts end -->
</div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-815452-5");
pageTracker._trackPageview();
} catch(err) {}</script>
  </body>
</html>

